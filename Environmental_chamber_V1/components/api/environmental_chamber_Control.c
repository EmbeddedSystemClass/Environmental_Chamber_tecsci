#include "environmental_chamber_Control.h"
//Standard libraries
#include <stdio.h>
#include <stdbool.h>
//ESP libraries
#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"
#include "sdkconfig.h" // generated by "make menuconfig"

//Bosch Sensor BME280 librarie
#include "bme280.h"
//Environmetal Chamber libraries
#include "sensor.h"
#include "humidifier.h"
#include "dryer.h"
#include "environmental_chamber_process.h"
#include "environmental_chamber_handlers.h"
#include "environmental_chamber_Control.h"
#include "environmental_chamber_monitor.h"
#include "custom_bool.h"
#include "PID_v1.h"

SemaphoreHandle_t xSemaphore_Stop_Control;
QueueHandle_t xQueue_Run_RH_control;

//Monitor definitions and funcions
chamberRunState_t process_RH_state=CHAMBER_STOPPED;
chamberRunState_t process_TEMP_state=CHAMBER_STOPPED;

chamberRunState_t get_process_RH_state(){
    return process_RH_state; //returns the global variable
}
chamberRunState_t get_process_TEMP_state(){
    return process_TEMP_state; //returns the global variable
}


// Control Initialization
void init_control_tasks(){

  //freertos Control task create
  xTaskCreate(&task_RH_Control_SetPoint,
   "task_RH_Control_SetPoint",
     2048,
  	 NULL,
  	 tskIDLE_PRIORITY+1,
  	 NULL
  );

  //Queue Initialization
  xQueue_Run_RH_control = xQueueCreate(2, sizeof(double)); // el largo de la cola es 1
  if (xQueue_Run_RH_control == NULL) {
    printf("Error creating xQueue_Run_RH_controls\n");
  }
  //Semaphore Initialization
  xSemaphore_Stop_Control=xSemaphoreCreateBinary();
  xSemaphoreTake( xSemaphore_Stop_Control, ( TickType_t ) 0 );
}


//enable RH task --> makes the RH control task to star running, till "stop" is called
void enable_RH_Task(double targetRH){
  /* Send an double. Wait for 10 ticks for space to become
available if necessary. */
if( xQueueSendToBack(xQueue_Run_RH_control,&targetRH,10) != pdPASS ){
    /* Failed to post the message, even after 10 ticks. */
    printf("Failed to post the message, even after 10 ticks\n");
}

}

void stop_RH_Task(){
   // if( xSemaphore_Stop_Control != NULL ){
   //     if( xSemaphoreGive(xSemaphore_Stop_Control) != pdTRUE ){
   //       printf("Error in xSemaphoreGive(xSemaphore_Stop_Control) \n");
   //     }
   // }
   xSemaphoreGive(xSemaphore_Stop_Control);
}


void task_RH_Control_SetPoint(){

  double actual_average_RH;
  double target_RH;

	while(1){

    printf("esperando cola\n");
     if (xQueueReceive( xQueue_Run_RH_control, &target_RH, portMAX_DELAY) == pdTRUE ){

        printf("corriendo RH control TASK --> %f \n",target_RH);

       while(xSemaphoreTake(xSemaphore_Stop_Control , 20/ portTICK_RATE_MS) == false){


         vTaskDelay(1000/portTICK_PERIOD_MS);

         actual_average_RH=get_actual_average_RH();

         printf("actual RH: %f\n",actual_average_RH );

       	if(actual_average_RH<=(target_RH+UPPER_LIM)&& actual_average_RH>=(target_RH-LOWER_LIM)){  //keep humidity
       		printf("State: keep Humidity\n");
          process_RH_state=CHAMBER_STOPPED;
       		humidifier_low();
       		dryer_low();

       	}

       	else if(actual_average_RH>(target_RH+UPPER_LIM)){  //dehumidify
       		printf("State: dehumidify\n");
          process_RH_state=CHAMBER_DRYINGUP;

       		humidifier_low();
       		dryer_high();

       	}

       	else if(actual_average_RH<(target_RH-LOWER_LIM)){  //humidify

       		printf("State: humidify\n");
          process_RH_state=CHAMBER_HUMIDIFYING;

       		humidifier_high();
       		dryer_low();
       	}

       }
       printf("saliendo del while\n");
       }
    }

}


void task_RH_Control_PID(){

  //usar el ejemplo PID_Adaptive_Tuning
  //y segun el valor de analog write decidir si es humidify, dry o nada



}

void task_TEMP_Control_SetPoint(){
}

void task_TEMP_Control_PID(){
}

void enable_TEMP_Task(double targetTEMP){

}
